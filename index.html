<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>動物騎士：穩定互動版</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.0/dist/mindar-image-aframe.prod.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        #status { 
            position: absolute; top: 0; width: 100%; 
            background: rgba(0,0,0,0.8); color: #FFD700; 
            padding: 12px; z-index: 100; text-align: center;
            font-family: sans-serif; font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="status">準備中，請對準圖卡...</div>

    <a-scene 
        id="ar-scene"
        mindar-image="imageTargetSrc: ./assets/targets.mind; autoStart: true; uiLoading: no; uiScanning: yes; maxTrack: 32;" 
        renderer="colorManagement: true, physicallyCorrectLights" 
        vr-mode-ui="enabled: false"
        device-orientation-permission-ui="enabled: false"
        cursor="fuse: false; rayOrigin: mouse;"
        raycaster="objects: .clickable">
        
        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
        <a-entity id="effect-container"></a-entity>
    </a-scene>

    <script>
        const status = document.querySelector('#status');
        const sceneEl = document.querySelector('#ar-scene');
        const activeModels = new Map();

        // --- 1. 互動組件 ---
        AFRAME.registerComponent('knight-logic', {
            init: function () {
                this.isDragging = false;
                this.el.classList.add('clickable'); 

                // 點擊跳躍
                this.el.addEventListener('click', () => {
                    this.jump();
                });

                // 拖曳開始
                this.el.addEventListener('mousedown', () => { 
                    this.isDragging = true; 
                    status.innerText = "抓取騎士中...";
                });

                // 拖曳結束
                window.addEventListener('mouseup', () => { 
                    if(this.isDragging) {
                        this.isDragging = false;
                        status.innerText = "騎士已就位";
                    }
                });

                // 拖曳移動
                window.addEventListener('mousemove', (e) => {
                    if (!this.isDragging) return;
                    const pos = this.el.getAttribute('position');
                    // 微調移動感應度
                    this.el.setAttribute('position', {
                        x: pos.x + e.movementX * 0.002,
                        y: pos.y,
                        z: pos.z + e.movementY * 0.002
                    });
                });
            },
            jump: function () {
                const p = this.el.object3D.position;
                this.el.setAttribute('animation__jump', {
                    property: 'position',
                    to: `${p.x} 0.5 ${p.z}`,
                    dur: 300,
                    easing: 'easeOutQuad',
                    dir: 'alternate',
                    loop: 1
                });
            }
        });

        // --- 2. 生成 32 隻角色 ---
        for (let i = 0; i < 32; i++) {
            const target = document.createElement('a-entity');
            target.setAttribute('mindar-image-target', `targetIndex: ${i}`);
            
            const model = document.createElement('a-gltf-model');
            model.setAttribute('rotation', '90 0 0');
            model.setAttribute('scale', '0.8 0.8 0.8');
            model.setAttribute('knight-logic', ''); 
            
            target.appendChild(model);
            sceneEl.appendChild(target);

            const modelId = i.toString().padStart(2, '0');

            target.addEventListener("targetFound", () => {
                console.log(`找到圖卡 Index: ${i}`);
                if (!model.getAttribute('src')) {
                    model.setAttribute('src', `./assets/${modelId}.glb`);
                }
                activeModels.set(i, model);
                status.innerText = `騎士 ${modelId} 參戰！`;
            });

            target.addEventListener("targetLost", () => {
                activeModels.delete(i);
            });
        }

        // --- 3. 物理引擎 (修正座標歪曲問題) ---
        AFRAME.registerComponent('collision-engine', {
            tick: function () {
                const models = Array.from(activeModels.values());
                if (models.length < 2) return;

                const minDist = 0.4;
                const pushStrength = 0.02;

                models.forEach((m1) => {
                    const logic = m1.components['knight-logic'];
                    if (logic && logic.isDragging) return;

                    let force = new THREE.Vector3(0, 0, 0);
                    const p1 = new THREE.Vector3();
                    m1.object3D.getWorldPosition(p1);

                    models.forEach((m2) => {
                        if (m1 === m2) return;
                        const p2 = new THREE.Vector3();
                        m2.object3D.getWorldPosition(p2);
                        
                        const d = p1.distanceTo(p2);
                        if (d < minDist && d > 0.01) {
                            const dir = new THREE.Vector3().subVectors(p1, p2);
                            dir.y = 0;
                            force.add(dir.normalize().multiplyScalar(pushStrength));
                        }
                    });

                    const cur = m1.getAttribute('position');
                    // 只有在有推力或偏移時才更新，並確保歸位
                    m1.setAttribute('position', {
                        x: (cur.x + force.x) * 0.95,
                        y: cur.y,
                        z: (cur.z + force.z) * 0.95
                    });
                });
            }
        });

        sceneEl.setAttribute('collision-engine', '');
    </script>
</body>
</html>